#!/bin/bash

#
# Helper script for the DargStack template.
#
# Requires sudo >= 1.8.21.
#

# Exit on errors, use last pipe error code, do not overwrite files, ensure
# variables exist
set -o errexit -o pipefail -o noclobber -o nounset

# Set color codes for use with echo
LIGHT_BLUE='\e[94m'
LIGHT_GREEN='\e[92m'
LIGHT_RED='\e[91m'
LIGHT_YELLOW='\e[93m'
NC='\e[0m'

if ! hash git 2>/dev/null
then
	echo -e "${LIGHT_BLUE}git${LIGHT_YELLOW} is not available.${NC}"

	if ! hash lsb_release 2>/dev/null
	then
		echo -e "${LIGHT_RED}Could not determine OS distribution!${NC}"
		echo -e "${LIGHT_BLUE}lsb_release${NC} is not available."
		exit 1
	fi

	if [[ ("$(lsb_release -is)" == "Debian")
		|| ("$(lsb_release -is)" == "Ubuntu") ]]
	then
		sudo apt-get install -y git
	else
		echo -e "${LIGHT_RED}Could not install ${LIGHT_BLUE}git${LIGHT_RED}" \
			" automatically!${NC}"
		echo -e "Please install it manually."
		exit 1
	fi
fi

# Get this script's directory
THIS=$(dirname "$(readlink -f "$0")")

# convert the project name to a valid DNS name
DIRECTORY_NAME=$(echo "${PWD##*/}" | sed -e "s/[^A-Za-z_]/-/g")
PROJECT_OWNER="${PWD%/*}"
PROJECT_OWNER="${PROJECT_OWNER##*/}"
PROJECT_NAME="${DIRECTORY_NAME%"_stack"}"

ADVERTISE_ADDR=""
MODE="development"
OFFLINE=false
URL="$(git remote get-url origin || true)"
VERSION=""

if [ "$URL" == "" ]
then
	URL="https://github.com/<owner>/<name>.git"
fi

function usage {
	echo -e "usage: ${0##*/} ${LIGHT_YELLOW}<module>${NC}" \
		"${LIGHT_YELLOW}<options>${NC}"
	echo -e ""
	echo -e "${LIGHT_YELLOW}modules${NC}"
	echo -e "    build [sibling]           Builds the main project or the" \
		"specified sibling, tagged as ${LIGHT_BLUE}dev${NC}. Only for" \
		"development."
	echo -e "    deploy                    Deploys a Docker project either" \
		"from a full local development clone of the project or, with the" \
		"${LIGHT_BLUE}--production${NC} parameter provided, by doing a" \
		"sparse Git checkout containing only the production configuration." \
		"In the latter case ${LIGHT_BLUE}derive${NC} is executed first and" \
		"the existence of required environment variables is checked before" \
		"deployment starts."
	echo -e "    derive                    Derives a" \
		"${LIGHT_BLUE}./production/stack.yml${NC} from" \
		"${LIGHT_BLUE}./development/stack.yml${NC}."
	echo -e "    rgen                      Generate the README." \
	echo -e "    rm                        Removes the stack."
	echo -e "    self-update               Updates the helper script."
	echo -e ""
	echo -e "${LIGHT_YELLOW}options${NC}"
	echo -e "    -a, --advertise-addr      The address Docker Swarm advertises."
	echo -e "    -h, --help                Display this help. Usable with" \
		"modules: all."
	echo -e "    -o, --offline             Do not try to update the checkout"
	echo -e "    -p, --production <tag>    Execute in production mode." \
		"Version must equal a tag name or ${LIGHT_BLUE}latest${NC}. Usable" \
		"with modules: ${LIGHT_BLUE}deploy${NC}."
	echo -e "    -u, --url <url>           The URL to clone from. May" \
		"include the substrings ${LIGHT_BLUE}<owner>${NC} and" \
		"${LIGHT_BLUE}<name>${NC} that are replaced by their corresponding" \
		"value that is inferred from the DargStack directory structure." \
		"Usable with modules: ${LIGHT_BLUE}deploy${NC}."
	exit 1
}

function docker_sudo() {
	if id -nG | grep -qw "docker"
	then
		docker "$@"
	else
		ENV_VARS_TO_PRESERVE="$(grep -v '^#' "./production/stack.env" | xargs \
			| sed -r 's/=[^ ]+//g' | sed -r 's/ /,/g')"

		if [ -z "${SUDO_PASSWORD+x}" ]
		then
			sudo --preserve-env="$ENV_VARS_TO_PRESERVE" docker "$@"
		else
			echo "$SUDO_PASSWORD" | \
				sudo -S --preserve-env="$ENV_VARS_TO_PRESERVE" docker "$@"
		fi
	fi
}

function deploy() {
	PROJECT_OWNER="$1"
	PROJECT_NAME="$2"
	VERSION="$3"
	URL="$4"
	MODE="$5"
	ADVERTISE_ADDR="$6"

	if [ "$MODE" = "production" ]
	then
		if [ ! -d "./.git" ]
		then
			echo -e "Initializing a sparse Git checkout..."

			git init
			git remote add origin "$URL"
			git config advice.detachedHead false
			git config core.sparsecheckout true

			{
				echo "development/stack.env.template"
				echo "development/stack.yml"
				echo "production/*"
			} >> "./.git/info/sparse-checkout"
		fi

		if [ "$OFFLINE" = true ]
		then
			echo -e "Skipping checkout update (offline mode)."
		else
			echo -e "Updating checkout..."

			git fetch -t
			git fetch --depth 1

			latest=false

			if [ "$VERSION" = "latest" ]
			then
				latest=true
			fi

			if [ "$(git tag -l)" = "" ]
			then
				echo -e "${LIGHT_YELLOW}The stack repository has no tags!${NC}"
				git checkout origin/master
			else
				if [ $latest = "true" ]
				then
					VERSION=$(git rev-list --tags --max-count=1)
				else
					VERSION=$(git rev-list --max-count=1 "$VERSION")
				fi

				git_describe=$(git describe --tags "$VERSION" 2>/dev/null) || true

				if [ "$git_describe" = "" ]
				then
					echo -e "${LIGHT_RED}Git describe failed!${NC}"

					if [ "$latest" = "true" ]
					then
						echo -e "${LIGHT_YELLOW}Make sure the stack" \
							"repository is tagged.${NC}"
					else
						echo -e "${LIGHT_YELLOW}Make sure the stack" \
							"repository has the ${LIGHT_BLUE}$VERSION" \
							"${LIGHT_YELLOW} tag.${NC}"
					fi

					exit 1
				fi

				# Update the sparse checkout (overwrite files that changed on
				# git, keeping files that are not part of the repository)
				git fetch --depth 1 origin tag "$git_describe"
				git checkout "$git_describe"
			fi
		fi

		echo -e "Searching for unset environment variables..."

		# Compare .env.template and .env files to find variables that are not
		# yet set.
		awk=""
		error=false

		while read -r -d $'\0' x
		do
			# Create environment variable file from template
			if [ ! -s "${x%.template}" ]
			then
				cp "$x" "${x%.template}"
			fi

			if [[ "$(echo "$x" | sed -n "/.env.template$/p")" != "" ]]
			then
				# Check if all environment variables are set
				awk=$(awk '
				{
					if (NR == FNR) {
						key = value = $0
						sub("=.*$", "", key)
						sub("^.*=", "", value)
						lines[key] = value
					}

					if ((NR != FNR) && ($0 !~ /(^#.*$|^$)/)) {
						sub("=", "")

						if (!($0 in lines) || (lines[$0] == "")) {
							print
						}
					}
				}' "${x%.template}" "$x")

				if [ "$awk" != "" ]
				then
					error=true
					echo -e "\n${LIGHT_RED}The following environment" \
						"variables are not set in ${LIGHT_BLUE}" \
						"${x%.template}${LIGHT_RED}:\n${LIGHT_YELLOW}$awk${NC}"
				fi
			fi
		done < <(find . -type f -name '*.template' -print0)

		if [ "$error" = true ]
		then
			exit 1
		else
			if [ ! -f "./production/stack.env" ]; then
				if [ -f "./development/stack.env" ]; then
					echo -e "Adding development environment variables..."

					cat "./development/stack.env" >> "./production/stack.env"
				fi

				if [ -f "./production/production.env" ]; then
					echo -e "Adding production environment variables..."

					cat "./production/production.env" >> \
						"./production/stack.env"
				fi
			fi

			if [ -f "./production/stack.env" ]; then
				echo -e "Exporting production environment variables..."

				export $(grep -v '^#' "./production/stack.env" | xargs)
			fi

			# Ensure Docker is part of a swarm
			if [ "$(docker_sudo info --format '{{.Swarm.LocalNodeState}}')" = \
				"inactive" ]
			then
				echo -e "Creating swarm..."

				if [ "$ADVERTISE_ADDR" == "" ]
				then
					docker_sudo swarm init
				else
					docker_sudo swarm init --advertise-addr "$ADVERTISE_ADDR"
				fi
			fi
		fi

		derive
	else
		if [ -f "./development/stack.env" ]; then
			echo -e "Exporting development environment variables..."

			export $(grep -v '^#' "./development/stack.env" | xargs)
		fi

		export "STACK_DOMAIN=$PROJECT_NAME.test"
	fi

	echo -e "Deploying ${LIGHT_BLUE}$PROJECT_NAME${NC} stack for" \
		"${LIGHT_BLUE}$MODE${NC}..."

	docker_sudo stack deploy -c "../${PROJECT_NAME}_stack/$MODE/stack.yml" \
		--with-registry-auth "$PROJECT_NAME"
}

function derive() {
	IN="$PWD/development/stack.yml"
	OUT="$PWD/production/stack.yml"
	seds=()

	echo -e "Deriving ${LIGHT_BLUE}./production/stack.yml${NC} from" \
		"${LIGHT_BLUE}./development/stack.yml${NC}..."

	cp "$IN" "$OUT"

	echo -e "Applying default seds..."

	sed -i "s/^.* #DARGSTACK-REMOVE$//g" "$OUT"
	sed -i "s/file:.*\.secret/external: true/g" "$OUT"
	sed -i "s/\.\/certificates\//acme_data/g" "$OUT"
	sed -i "s/\.\.\/production/\./g" "$OUT"

	if [ -f "./production/production.sed" ]
	then
		echo -e "Applying seds from" \
			"${LIGHT_BLUE}./production/production.sed${NC}..."

		readarray -t seds < "./production/production.sed"

		for sed_string in "${seds[@]}"
		do
			sed -i "$sed_string" "$OUT"
		done
	fi

	if [ -f "./production/production.yml" ]
	then
		echo -e "Merging ${LIGHT_BLUE}./production/production.yml${NC}..."
		echo "$(docker_sudo run --rm -v "$OUT:/manifests/stack.yml" -v \
		"$PWD/production/production.yml:/manifests/production.yml" \
		gfranks/spruce spruce merge /manifests/stack.yml \
		/manifests/production.yml)" >| "$OUT"
	fi
}

function rgen() {
	OUT="$PWD/README.md"

	echo -e "Merging ${LIGHT_BLUE}./production/production.yml${NC}..."
	docker_sudo run --rm -v "$PWD:/mnt/$DIRECTORY_NAME" \
		dargmuesli/dargstack_rgen --path "/mnt/$DIRECTORY_NAME" \
		>| "$OUT"
}

# Check if getopt is available
! getopt --test > /dev/null
if [[ ${PIPESTATUS[0]} -ne 4 ]]
then
	echo -e "${LIGHT_RED}Cannot parse parameters!${NC}"
	exit 1
fi

# Parse command line parameters
OPTIONS=a:hop:u:
LONGOPTS=advertise_addr:,help,offline,production:,url:

! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS \
	--name "$0" -- "$@")
if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
	exit 2
fi

eval set -- "$PARSED"

while true
do
	case "$1" in
		-a|--advertise-addr)
			ADVERTISE_ADDR="$2"
			shift 2
			;;
		-h|--help)
			echo -e "DargStack template helper script."
			echo -e ""
			usage
			;;
		-o|--offline)
			OFFLINE=true
			shift 1
			;;
		-p|--production)
			MODE="production"
			VERSION="$2"
			shift 2
			;;
		-u|--url)
			URL="$2"
			shift 2
			;;
		--)
			shift
			break
			;;
		*)
			echo -e "${LIGHT_RED}Programming error!${NC}"
			exit 2
			;;
	esac
done

if [[ $# -gt 2 ]]
then
	echo -e "${LIGHT_YELLOW}ignoring everything after $2${NC}!"
fi

if [ $# -lt 1 ]
then
	echo -e "${LIGHT_RED}No module parameter provided!${NC}"
	usage
	exit 1
elif [[ "$1" != "build" && "$1" != "deploy" && "$1" != "derive" && \
	"$1" != "rgen" && "$1" != "rm" && "$1" != "self-update" ]]
then
	echo -e "${LIGHT_RED}Parameter '$1' equals neither" \
	"${LIGHT_BLUE}build${LIGHT_RED} nor ${LIGHT_BLUE}deploy${LIGHT_RED} nor" \
	"${LIGHT_BLUE}derive${LIGHT_RED} nor ${LIGHT_BLUE}rm${LIGHT_RED}!" \
	"nor ${LIGHT_BLUE}self-update${LIGHT_RED}!${NC}"
	exit 1
fi

if [[ ("$1" = "build" || "$1" = "deploy") \
	&& "$MODE" = "development" && (! -d "../$PROJECT_NAME") ]]
then
	echo -e "${LIGHT_RED}Running in ${LIGHT_BLUE}development${LIGHT_RED}" \
		"mode, but directory ${LIGHT_BLUE}../$PROJECT_NAME${LIGHT_RED} does" \
		"not exist!${NC}"
	exit 1
fi

URL=${URL/"<owner>"/$PROJECT_OWNER}
URL=${URL/"<name>"/${PROJECT_NAME}_stack}

echo -e "DargStack project ${LIGHT_BLUE}$URL${NC} for" \
	"${LIGHT_BLUE}$MODE${NC}.\n"

case "$1" in
"build")
	project="$PROJECT_NAME"

	if [ "${2+defined}" = "defined" ]
	then
		project+="_$2"
	fi

	echo -e "Building ${LIGHT_BLUE}$PROJECT_OWNER/$project:dev${NC}..."

	if [ "$MODE" == "production" ]
	then
		docker_sudo build -t "$PROJECT_OWNER/$project:$VERSION" "../$project/"
	else
		docker_sudo build -t "$PROJECT_OWNER/$project:dev" \
			--target=development "../$project/"
	fi
	;;
"deploy")
	deploy "$PROJECT_OWNER" "$PROJECT_NAME" "$VERSION" "$URL" "$MODE" \
		"$ADVERTISE_ADDR"
	;;
"derive")
	derive
	;;
"rgen")
	rgen
	;;
"rm")
	echo -e "Removing stack ${LIGHT_BLUE}$PROJECT_NAME${NC}..."
	docker_sudo stack rm "$PROJECT_NAME"
	;;
"self-update")
	wget "$(printf "%s" \
		"https://raw.githubusercontent.com/" \
		"dargmuesli/dargstack/master/dargstack")" -O "$THIS/dargstack"
	chmod +x "$THIS/dargstack"
	;;
esac

echo -e "\n${LIGHT_GREEN}Done${NC}"
